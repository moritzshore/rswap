status <- run_swap(
project_path = project_path,
swap_file = "swap.swp",
swap_exe = swap_exe ,
autoset_output = T,
verbose = T,
timeout = 100
)
plot_over_under(project_path,variable = "WC", depth = c(15, 40, 70))
status <- run_swap(
project_path = project_path,
swap_file = "swap.swp",
swap_exe = swap_exe ,
autoset_output = T,
verbose = T,
timeout = 100
)
# builds a directory for performing package actions, and returns the path
rswap_directory <- build_rswap_directory(project_path)
# reads in the swap parameters and tables
parse_result <- parse_swp_file(project_path = project_path,
swap_file = swap_file,
verbose = verbose)
# changes the paths in the swap main file to reflect the temporary location
params <- update_swp_paths(project_path, swap_exe,
parse_result$parameters, verbose)
View(params)
params
obs <- load_observed(path = observed_path)
# reads in the swap parameters and tables
parse_result <- parse_swp_file(project_path = project_path,
swap_file = swap_file,
verbose = verbose)
# changes the paths in the swap main file to reflect the temporary location
params <- update_swp_paths(project_path, swap_exe,
parse_result$parameters, verbose)
observed_path <- paste0(rswap_directory, "/rswap_observed_data.xlsx")
obs <- load_observed(path = observed_path)
variables <- obs$observed_variables
depths <- get_depths(data = obs$data) %>% sort()
# add the critical output params if they are not present.
if("INLIST_CSV" %in% params$param == FALSE){
add <- data.frame(param = "INLIST_CSV", value = "", comment = glue("added by rswap on {Sys.time()}"))
params <- rbind(params, add)
}
("INLIST_CSV" %in% params$param
("INLIST_CSV" %in% params$param
"INLIST_CSV" %in% params$param
"INLIST_CSV" %in% params$param
"INLIST_CSV" %in% params$param
"INLIST_CSV" %in% params$param
# add the critical output params if they are not present.
if("SWCSV_TZ" %in% params$param == FALSE){
add <- data.frame(param = "SWCSV_TZ", value = "", comment = glue("added by rswap on {Sys.time()}"))
params <- rbind(params, add)
}
"SWCSV_TZ" %in% params$param
"SWCSV_TZ" %in% params$param
"SWCSV_TZ" %in% params$param
View(params)
status <- run_swap(
project_path = project_path,
swap_file = "swap.swp",
swap_exe = swap_exe ,
autoset_output = T,
verbose = T,
timeout = 100
)
library(rswap)
params$param
"INLIST_CSV_TZ = 'WC,H,TEMP'"
status <- run_swap(
project_path = project_path,
swap_file = "swap.swp",
swap_exe = swap_exe ,
autoset_output = T,
verbose = T,
timeout = 100
)
library(rswap)
plot_over_under(project_path,variable = "WC", depth = c(15, 40, 70))
project_path
read_swap_output(project_path)
hi <- read_swap_output(project_path)
hi$daily_output
hi$custom_depth
run_name <- project_path %>% str_split("./") %>% unlist() %>% tail(1)
if (observed_file_path %>% is.null()) {
observed_file_path <- glue("{project_path}/rswap_observed_data.xlsx")
}
observed_file_path <- glue("{project_path}/rswap_observed_data.xlsx")
project_path
observed_data <- load_observed(path = observed_file_path, verbose = verbose)
observed_data
if(depth %>% is.null()){
depth = get_depths(observed_data$data, variable = variable)
}
depth = get_depths(observed_data$data, variable = variable)
depth
depth = get_depths(observed_data$data, variable = variable)
variable = "WC"
depth = get_depths(observed_data$data, variable = variable)
index = 1
total = length(depth)
# special routine if depth is null
if(depth %>% is.null()){
rlist <-
match_mod_obs(
project_path = project_path,
variable = variable,
observed_file_path = observed_file_path,
verbose = verbose
)
modelled_data_filtered = rlist$mod
observed_data_filtered = rlist$obs
res_crop <- left_join(observed_data_filtered, modelled_data_filtered, by  = "DATE")
# rename the columns
colnames(res_crop) <- c("DATE", "mod", "obs")
# reformat the data to be compatible with the ribbonize function
mydf <- tibble(
x = c(1:length(res_crop$DATE),1:length(res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = c(rep("model", length(res_crop$DATE)), rep("observed", length(res_crop$DATE)))
)
# generate the ribbons
ribbons <- ribbonize(mydf, x, y, type)
# replace the x axis with the date (must be in character format, no support
# for date...)
mydf2 <-
tibble(
x = as.character(c(res_crop$DATE, res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = mydf$type
)
# generate the plot. GGPLOT wont show linetype correctly so we need to pass
# it to plotly which does.
p <- ggplot(mydf2) +
geom_line(aes(x, y, linetype = type, color = type, group = type)) +
geom_ribbon(data = ribbons, aes(x, ymin = ymin, ymax = ymax, fill = fill), alpha = 0.4) +
guides(linetype = "none", fill = "none") +
scale_color_manual(values = c("black","black"))+
scale_linetype_manual(values = c(3, 1)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank())+
scale_x_discrete(name = "Date", breaks = mydf2$x[mydf2$x %>% substr(.,8,10) %>% grepl(x = ., "-01") %>% which()])+
labs(y =get_swap_units(variable))
p %>% ggplotly(tooltip = "y" )  %>%
layout(title = list(text = paste(run_name, variable), y = 0.99), hovermode = "x unified") %>%
print()
}else{
for (cdepth in depth) {
rlist <-
match_mod_obs(
project_path = project_path,
variable = variable,
observed_file_path = observed_file_path,
depth = cdepth,
verbose = verbose
)
modelled_data_filtered = rlist$mod
observed_data_filtered = rlist$obs
res_crop <- left_join(observed_data_filtered, modelled_data_filtered, by  = "DATE")
# rename the columns
colnames(res_crop) <- c("DATE", "mod", "obs")
# reformat the data to be compatible with the ribbonize function
mydf <- tibble(
x = c(1:length(res_crop$DATE),1:length(res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = c(rep("model", length(res_crop$DATE)), rep("observed", length(res_crop$DATE)))
)
# generate the ribbons
ribbons <- ribbonize(mydf, x, y, type)
# replace the x axis with the date (must be in character format, no support
# for date...)
mydf2 <-
tibble(
x = as.character(c(res_crop$DATE, res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = mydf$type
)
# generate the plot. GGPLOT wont show linetype correctly so we need to pass
# it to plotly which does.
p <- ggplot(mydf2) +
geom_line(aes(x, y, linetype = type, color = type, group = type)) +
geom_ribbon(data = ribbons, aes(x, ymin = ymin, ymax = ymax, fill = fill), alpha = 0.4) +
guides(linetype = "none", fill = "none") +
scale_color_manual(values = c("black","black"))+
scale_linetype_manual(values = c(3, 1)) +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
theme(legend.title = element_blank())+
scale_x_discrete(name = "Date", breaks = mydf2$x[mydf2$x %>% substr(.,8,10) %>% grepl(x = ., "-01") %>% which()])+
labs(y =get_swap_units(variable))
p %>% ggplotly(tooltip = "y")  %>%
layout(title = list(text = paste(run_name, variable, "depth:", cdepth, "cm"), y = 0.99), hovermode = "x unified") %>%
print()
# todo, clean up the graph
# todo tidy up this readline thing
if(index < total){
index = index+1
readline(prompt = paste0("hit enter for next depth (", depth[index], ")"))
}
}
}
library(stringi)
rlist <-
match_mod_obs(
project_path = project_path,
variable = variable,
observed_file_path = observed_file_path,
depth = cdepth,
verbose = verbose
)
modelled_data_filtered = rlist$mod
observed_data_filtered = rlist$obs
res_crop <- left_join(observed_data_filtered, modelled_data_filtered, by  = "DATE")
cdepth = depth[1]
rlist <-
match_mod_obs(
project_path = project_path,
variable = variable,
observed_file_path = observed_file_path,
depth = cdepth,
verbose = verbose
)
modelled_data_filtered = rlist$mod
observed_data_filtered = rlist$obs
res_crop <- left_join(observed_data_filtered, modelled_data_filtered, by  = "DATE")
# rename the columns
colnames(res_crop) <- c("DATE", "mod", "obs")
# reformat the data to be compatible with the ribbonize function
mydf <- tibble(
x = c(1:length(res_crop$DATE),1:length(res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = c(rep("model", length(res_crop$DATE)), rep("observed", length(res_crop$DATE)))
)
# generate the ribbons
ribbons <- ribbonize(mydf, x, y, type)
#' ribbionize
#'
#' author: Neal Grantham
#' source: https://www.nsgrantham.com/fill-between-two-lines-ggplot2
#' @keywords internal
#' @importFrom dplyr %>% pull filter count group_by mutate select distinct
#' @importFrom dplyr transmute arrange recode lead bind_rows
#' @importFrom tidyr pivot_wider pivot_longer
ribbonize <- function(.data, .x, .y, .type) {
# Calculate the ribbons required for geom_ribbon().
# For more info, visit nsgrantham.com/fill-between-two-lines-ggplot2
#
# Usage:
# df <- tibble(
#   x = c(1:8, 1:8),
#   y = c(1, 5, 6, 4, 1, 1, 3, 2, 1, 4, 5, 4, 2, 2, 2, 2),
#   type = c(rep("model", 8), rep("observed", 8))
# )
#
# ribbons <- ribbonize(df, x, y, type)
#
# ggplot(df) +
#   geom_line(aes(x, y, linetype = type)) +
#   geom_ribbon(data = ribbons, aes(x, ymin = ymin, ymax = ymax, fill = fill))
# Check there are only 2 level in .type
levels <- .data %>%
pull({{ .type }}) %>%
unique()
stopifnot(length(levels) == 2)
# Check that there is exactly 1 observation per level in .type at every .x
level_counts_by_x <- .data %>%
filter(!is.na({{ .y }})) %>%
group_by({{ .x }}) %>%
count() %>%
pull(n)
stopifnot(all(level_counts_by_x == 2))
bounds <- .data %>%
mutate({{ .type }} := recode({{ .type }}, model = levels[1], observed = levels[2])) %>%
pivot_wider(names_from = {{ .type }}, values_from = {{ .y }}) %>%
mutate(
ymax = pmax(model, observed),
ymin = pmin(model, observed),
fill = model >= observed
)
intervals <- bounds %>%
filter(ymax > ymin) %>%
select(-model, -observed)
intersections <- bounds %>%
mutate(lag_fill = lag(fill), lead_fill = lead(fill)) %>%
filter(ymax == ymin) %>%
select(-model, -observed, -fill) %>%
pivot_longer(lag_fill:lead_fill, names_to = NULL, values_to = "fill") %>%
filter(!is.na(fill)) %>%
distinct()
other_intersections <- bounds %>%
transmute(
x1 = {{ .x }},       y1 = model,
x2 = lead({{ .x }}), y2 = lead(model),
x3 = {{ .x }},       y3 = observed,
x4 = lead({{ .x }}), y4 = lead(observed)
) %>%
filter(((y1 > y3) & (y2 < y4)) | ((y1 < y3) & (y2 > y4))) %>%
mutate(
d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4),
u = x1 * y2 - y1 * x2,
v = x3 * y4 - y3 * x4,
x = (u * (x3 - x4) - v * (x1 - x2)) / d,
y = (u * (y3 - y4) - v * (y1 - y2)) / d
) %>%
select(x, ymax = y, ymin = y)
bind_rows(
intervals,
intersections,
mutate(other_intersections, fill = TRUE),
mutate(other_intersections, fill = FALSE)
) %>%
arrange({{ .x }})
}
rlist <-
match_mod_obs(
project_path = project_path,
variable = variable,
observed_file_path = observed_file_path,
depth = cdepth,
verbose = verbose
)
modelled_data_filtered = rlist$mod
observed_data_filtered = rlist$obs
res_crop <- left_join(observed_data_filtered, modelled_data_filtered, by  = "DATE")
# rename the columns
colnames(res_crop) <- c("DATE", "mod", "obs")
# reformat the data to be compatible with the ribbonize function
mydf <- tibble(
x = c(1:length(res_crop$DATE),1:length(res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = c(rep("model", length(res_crop$DATE)), rep("observed", length(res_crop$DATE)))
)
# generate the ribbons
ribbons <- ribbonize(mydf, x, y, type)
mydf
x
# reformat the data to be compatible with the ribbonize function
mydf <- tibble(
x = c(1:length(res_crop$DATE),1:length(res_crop$DATE)),
y = c(res_crop$mod, res_crop$obs),
type = c(rep("model", length(res_crop$DATE)), rep("observed", length(res_crop$DATE)))
)
# generate the ribbons
ribbons <- ribbonize(mydf, x, y, type)
View(mydf)
View(mydf)
any(mydf$y %>% is.na())
library(rswap)
plot_over_under(project_path,variable = "WC", depth = c(15, 40, 70))
rswap::save_run(project_path, verbose = T)
observed_data <- rswap::load_observed(path = observed, verbose = T)
modelled_data <- read_swap_output(project_path = project_path)
get_depths(observed_data$data)
get_depths(observed_data$data,variable = "H")
get_depths(observed_data$data,variable = "WC")
filter_swap_data(data = observed_data$data, var = "WC", depth = 15)
filter_swap_data(data = modelled_data$custom_depth, var = "DRAINAGE")
get_performance(project_path, stat = "NSE", variable = "WC", depth = 15)
get_performance(project_path, stat = "NSE", variable = c("WC", "H", "TEMP"))
soft_calibration_plot(project_path, vars = c("H", "WC", "DRAINAGE"))
rswap::match_mod_obs(project_path, variable = "H", observed_file_path = observed, depth = NULL)
grilled_cheese <- rswap::melt_all_runs(project_path, variable = "WC",depth = 15)
library(ggplot2)
ggplot(grilled_cheese)+geom_line(aes(x = DATE, y = value, color = run, linetype = tag))
plot_statistics(project_path, var = "WC", depth = c(15,40, 70), graph = "ggplot")
rswap::
# opens SWAP file
paste0(project_path, "/", swap_file) %>% file.edit()
project_path = "C:/Users/mosh/Documents/tetves"
observed = "C:/Users/mosh/Documents/tetves/rswap_observed_data.xlsx"
swap_exe = "C:/Users/mosh/Documents/swap.exe"
swap_file = "swap.swp"
library(rswap)
swap_exe = "C:/Users/mosh/Documents/Zoom/swap.exe"
swap_file = "swap.swp"
# run the normal swap
run_swap(
project_path = "C:/Users/mosh/Documents/tetves",
swap_exe = "C:/Users/mosh/Documents/swap.exe",
swap_file = "swap.swp",autoset_output = F,
verbose = T
)
# builds a directory for performing package actions, and returns the path
rswap_directory <- build_rswap_directory(project_path)
# reads in the swap parameters and tables
parse_result <- parse_swp_file(project_path = project_path,
swap_file = swap_file,
verbose = verbose)
# changes the paths in the swap main file to reflect the temporary location
params <- update_swp_paths(project_path, swap_exe,
parse_result$parameters, verbose)
observed_path <- paste0(rswap_directory, "/rswap_observed_data.xlsx")
if (autoset_output) {
obs <- load_observed(path = observed_path)
variables <- obs$observed_variables
depths <- get_depths(data = obs$data) %>% sort()
# sets the "INLIST_CSV" parameters
# add the critical output params if they are not present.
if("INLIST_CSV" %in% params$param == FALSE){
add <- data.frame(param = "INLIST_CSV", value = "", comment = glue("added by rswap on {Sys.time()}"))
params <- rbind(params, add)
}
# add the critical output params if they are not present.
if("SWCSV_TZ" %in% params$param == FALSE){
add <- data.frame(param = "SWCSV_TZ", value = "1", comment = glue("added by rswap on {Sys.time()}"))
params <- rbind(params, add)
}
# add the critical output params if they are not present.
if("INLIST_CSV_TZ " %in% params$param == FALSE){
add <- data.frame(param = "INLIST_CSV_TZ ", value = "'WC,H,TEMP'", comment = glue("added by rswap on {Sys.time()}"))
params <- rbind(params, add)
}else{
params$value[which(params$param=="INLIST_CSV_TZ")] = 'WC,H,TEMP'
}
params <- set_swap_output(params, variables, depths, verbose)
inlistcsv <- params$value[which(params$param == "INLIST_CSV")]
inlistcsv <- inlistcsv %>% str_split("!") %>% unlist()
inlistcsv <- inlistcsv[1]
# print
if (verbose) {
cat(
"\n...autosetting SWAP output to match observed files:\n",
"INLIST_CSV = ",
inlistcsv,
"\n"
)
}
}
# change console output based on verbose flag
if (verbose) {
params <- change_swap_par(params, "SWSCRE", 2)
}else{
params <- change_swap_par(params, "SWSCRE", 0)
}
# location for where the swap file is to be written
outpath <- paste0(rswap_directory, swap_file)
rswap_file <- write_swap_file(
parameters = params,
table_path = parse_result$table_path,
outpath = outpath,
verbose = verbose
)
# parse the working directory from the given swap path
swap_path_split = swap_exe %>% str_split("swap.exe", simplify = T)
swap_wd <- swap_path_split[, 1]
# remove the working directory from the path of the swap main file
fixed_path <- rswap_file %>% str_remove(swap_wd)
# run the model
msg <- run(
command = "swap.exe",
wd = swap_wd,
args = fixed_path,
error_on_status = F,
timeout = timeout,
echo_cmd = verbose,
echo = verbose
)
msg
swap_wd
fixed_path
verbose
verbose = T
# run the model
msg <- run(
command = "swap.exe",
wd = swap_wd,
args = fixed_path,
error_on_status = F,
timeout = timeout,
echo_cmd = verbose,
echo = verbose
)
fixed_path
project_path
rswap_file
rswap_file = "C:/Users/mosh/Documents/tetves/nicht/swap.swp"
# parse the working directory from the given swap path
swap_path_split = swap_exe %>% str_split("swap.exe", simplify = T)
swap_wd <- swap_path_split[, 1]
# remove the working directory from the path of the swap main file
fixed_path <- rswap_file %>% str_remove(swap_wd)
fixed_path
swap_wd
swap_path_split
# run the model
msg <- run(
command = "swap.exe",
wd = swap_wd,
args = fixed_path,
error_on_status = F,
timeout = timeout,
echo_cmd = verbose,
echo = verbose
)
swap_wd
fixed_path
# run the model
msg <- run(
command = "swap.exe",
wd = swap_wd,
args = fixed_path,
error_on_status = F,
timeout = timeout,
echo_cmd = verbose,
echo = verbose
)
verbose
timeout
error_on_status
fixed_path
